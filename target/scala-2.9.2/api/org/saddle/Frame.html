<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>org.saddle.Frame</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../lib/template.css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
    
        </head>
        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="type">
      <div id="definition">
        <a title="Go to companion" href="Frame$.html"><img src="../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a name="org" class="extype" href="../package.html">org</a>.<a name="org.saddle" class="extype" href="package.html">saddle</a></p>
        <h1><a title="Go to companion" href="Frame$.html">Frame</a></h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Frame</span><span class="tparams">[<span name="RX">RX</span>, <span name="CX">CX</span>, <span name="T">T</span>]</span><span class="result"> extends <a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a>[<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]]</span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><p><code>Frame</code> is an immutable container for 2D data which is indexed along both axes
(rows, columns) by associated keys (i.e., indexes).</p><p>The primary use case is homogeneous data, but a secondary concern is to support
heterogeneous data that is homogeneous ony within any given column.</p><p>The row index, column index, and constituent value data are all backed ultimately
by arrays.</p><p><code>Frame</code> is effectively a doubly-indexed associative map whose row keys and col keys
each have an ordering provided by the natural (provided) order of their backing
arrays.</p><p>Several factory and access methods are provided. In the following examples, assume
that:</p><pre>
  <span class="kw">val</span> f = Frame(<span class="lit">'a'</span>-&gt;Vec(<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>), <span class="lit">'b'</span>-&gt;Vec(<span class="num">4</span>,<span class="num">5</span>,<span class="num">6</span>))
</pre><p>The <code>apply</code> method takes a row and col key returns a slice of the original Frame:</p><pre>
  f(<span class="num">0</span>,<span class="lit">'a'</span>) == Frame(<span class="lit">'a'</span>-&gt;Vec(<span class="num">1</span>))
</pre><p><code>apply</code> also accepts a <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>:</p><pre>
  f(<span class="num">0</span>-&gt;<span class="num">1</span>, <span class="lit">'b'</span>) == Frame(<span class="lit">'b'</span>-&gt;Vec(<span class="num">4</span>,<span class="num">5</span>))
  f(<span class="num">0</span>, *) == Frame(<span class="lit">'a'</span>-&gt;Vec(<span class="num">1</span>), <span class="lit">'b'</span>-&gt;Vec(<span class="num">4</span>))
</pre><p>You may slice using the <code>col</code> and <code>row</code> methods respectively, as follows:</p><pre>
  f.col(<span class="lit">'a'</span>) == Frame(<span class="lit">'a'</span>-&gt;Vec(<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>))
  f.row(<span class="num">0</span>) == Frame(<span class="lit">'a'</span>-&gt;Vec(<span class="num">1</span>), <span class="lit">'b'</span>-&gt;Vec(<span class="num">4</span>))
  f.row(<span class="num">0</span>-&gt;<span class="num">1</span>) == Frame(<span class="lit">'a'</span>-&gt;Vec(<span class="num">1</span>,<span class="num">2</span>), <span class="lit">'b'</span>-&gt;Vec(<span class="num">4</span>,<span class="num">5</span>))
</pre><p>You can achieve a similar effect with <code>rowSliceBy</code> and <code>colSliceBy</code></p><p>The <code>colAt</code> and <code>rowAt</code> methods take an integer offset i into the Frame, and
return a Series indexed by the opposing axis:</p><pre>
  f.rowAt(<span class="num">0</span>) == Series(<span class="lit">'a'</span>-&gt;<span class="num">1</span>, <span class="lit">'b'</span>-&gt;<span class="num">4</span>)
</pre><p>If there is a one-to-one relationship between offset i and key (ie, no duplicate
keys in the index), you may achieve the same effect via key as follows:</p><pre>
  f.first(<span class="num">0</span>) == Series(<span class="lit">'a'</span>-&gt;<span class="num">1</span>, <span class="lit">'b'</span>-&gt;<span class="num">4</span>)
  f.firstCol(<span class="lit">'a'</span>) == Series(<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>)
</pre><p>The <code>at</code> method returns an instance of a <a name="org.saddle.scalar.Scalar" class="extype" href="scalar/Scalar.html">Scalar</a>, which behaves
much like an <code>Option</code>; it can be either an instance of org.saddle.scalar.NA or a
<a name="org.saddle.scalar.Value" class="extype" href="scalar/Value.html">Value</a> case class:</p><pre>
  f.at(<span class="num">0</span>, <span class="num">0</span>) == scalar.Scalar(<span class="num">1</span>)
</pre><p>The <code>rowSlice</code> and <code>colSlice</code> methods allows slicing the Frame for locations in [i, j)
irrespective of the value of the keys at those locations.</p><pre>
  f.rowSlice(<span class="num">0</span>,<span class="num">1</span>) == Frame(<span class="lit">'a'</span>-&gt;Vec(<span class="num">1</span>), <span class="lit">'b'</span>-&gt;Vec(<span class="num">4</span>))
</pre><p>Finally, the method <code>raw</code> accesses a value directly, which may reveal the underlying
representation of a missing value (so be careful).</p><pre>
  f.raw(<span class="num">0</span>,<span class="num">0</span>) == <span class="num">1</span>
</pre><p><code>Frame</code> may be used in arithmetic expressions which operate on two <code>Frame</code>s or on a
<code>Frame</code> and a scalar value. In the former case, the two Frames will automatically
align along their indexes:</p><pre>
  f + f.shift(<span class="num">1</span>) == Frame(<span class="lit">'a'</span>-&gt;Vec(NA,<span class="num">3</span>,<span class="num">5</span>), <span class="lit">'b'</span>-&gt;Vec(NA,<span class="num">9</span>,<span class="num">11</span>))
</pre></div><dl class="paramcmts block"><dt class="tparam">RX</dt><dd class="cmt"><p>The type of row keys</p></dd><dt class="tparam">CX</dt><dd class="cmt"><p>The type of column keys</p></dd><dt class="tparam">T</dt><dd class="cmt"><p>The type of entries in the frame
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a>[<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]], AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="org.saddle.Frame" class="in"><span>Frame</span></li><li name="org.saddle.ops.NumericOps" class="in"><span>NumericOps</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div class="members" id="constructors">
              <h3>Instance Constructors</h3>
              <ol><li visbl="pub" name="org.saddle.Frame#this" data-isabs="false">
      <a id="this:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Frame</span><span class="params">(<span name="values">values: <a name="org.saddle.mat.MatCols" class="extype" href="mat/MatCols.html">MatCols</a>[T]</span>, <span name="rowIx">rowIx: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[RX]</span>, <span name="colIx">colIx: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[CX]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[RX]</span>, <span name="arg1">arg1: ORD[RX]</span>, <span name="arg2">arg2: ST[CX]</span>, <span name="arg3">arg3: ORD[CX]</span>, <span name="arg4">arg4: ST[T]</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">values</dt><dd class="cmt"><p>A sequence of Vecs which comprise the columns of the Frame</p></dd><dt class="param">rowIx</dt><dd class="cmt"><p>An index for the rows</p></dd><dt class="param">colIx</dt><dd class="cmt"><p>An index for the columns</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#%" data-isabs="false">
      <a id="%[B, That](B)(BinOp[Mod, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $percent">%</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.Mod" class="extype" href="ops/Mod.html">Mod</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Integer modulus of division</p><div class="fullcomment"><div class="comment cmt"><p>Integer modulus of division</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance (divisor)</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&amp;" data-isabs="false">
      <a id="&amp;[B, That](B)(BinOp[BitAnd, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $amp">&amp;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.BitAnd" class="extype" href="ops/BitAnd.html">BitAnd</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Bit-wise AND</p><div class="fullcomment"><div class="comment cmt"><p>Bit-wise AND</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&amp;&amp;" data-isabs="false">
      <a id="&amp;&amp;[B, That](B)(BinOp[AndOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $amp$amp">&amp;&amp;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.AndOp" class="extype" href="ops/AndOp.html">AndOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Logical AND</p><div class="fullcomment"><div class="comment cmt"><p>Logical AND</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#*" data-isabs="false">
      <a id="*[B, That](B)(BinOp[Multiply, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $times">*</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.Multiply" class="extype" href="ops/Multiply.html">Multiply</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Multiplication</p><div class="fullcomment"><div class="comment cmt"><p>Multiplication</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#**" data-isabs="false">
      <a id="**[B, That](B)(BinOp[Power, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $times$times">**</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.Power" class="extype" href="ops/Power.html">Power</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Exponentiation</p><div class="fullcomment"><div class="comment cmt"><p>Exponentiation</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance (exponent)</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#+" data-isabs="false">
      <a id="+[B, That](B)(BinOp[Add, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus">+</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.Add" class="extype" href="ops/Add.html">Add</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Addition</p><div class="fullcomment"><div class="comment cmt"><p>Addition</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#-" data-isabs="false">
      <a id="-[B, That](B)(BinOp[Subtract, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $minus">-</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.Subtract" class="extype" href="ops/Subtract.html">Subtract</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Subtraction</p><div class="fullcomment"><div class="comment cmt"><p>Subtraction</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#/" data-isabs="false">
      <a id="/[B, That](B)(BinOp[Divide, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $div">/</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.Divide" class="extype" href="ops/Divide.html">Divide</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Division</p><div class="fullcomment"><div class="comment cmt"><p>Division</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance (divisor)</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&lt;" data-isabs="false">
      <a id="&lt;[B, That](B)(BinOp[LtOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $less">&lt;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.LtOp" class="extype" href="ops/LtOp.html">LtOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Less-than comparison operator</p><div class="fullcomment"><div class="comment cmt"><p>Less-than comparison operator</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&lt;&lt;" data-isabs="false">
      <a id="&lt;&lt;[B, That](B)(BinOp[BitShl, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $less$less">&lt;&lt;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.BitShl" class="extype" href="ops/BitShl.html">BitShl</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Bit-shift left</p><div class="fullcomment"><div class="comment cmt"><p>Bit-shift left</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&lt;=" data-isabs="false">
      <a id="&lt;=[B, That](B)(BinOp[LteOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $less$eq">&lt;=</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.LteOp" class="extype" href="ops/LteOp.html">LteOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Less-than-or-equal-to comparison operator</p><div class="fullcomment"><div class="comment cmt"><p>Less-than-or-equal-to comparison operator</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&lt;&gt;" data-isabs="false">
      <a id="&lt;&gt;[B, That](B)(BinOp[NeqOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $less$greater">&lt;&gt;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.NeqOp" class="extype" href="ops/NeqOp.html">NeqOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Element-wise inequality operator</p><div class="fullcomment"><div class="comment cmt"><p>Element-wise inequality operator</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#=?" data-isabs="false">
      <a id="=?[B, That](B)(BinOp[EqOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$qmark">=?</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.EqOp" class="extype" href="ops/EqOp.html">EqOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Element-wise equality operator</p><div class="fullcomment"><div class="comment cmt"><p>Element-wise equality operator</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&gt;" data-isabs="false">
      <a id="&gt;[B, That](B)(BinOp[GtOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $greater">&gt;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.GtOp" class="extype" href="ops/GtOp.html">GtOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Greater-than comparison operator</p><div class="fullcomment"><div class="comment cmt"><p>Greater-than comparison operator</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&gt;=" data-isabs="false">
      <a id="&gt;=[B, That](B)(BinOp[GteOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $greater$eq">&gt;=</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.GteOp" class="extype" href="ops/GteOp.html">GteOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Greater-than-or-equal-to comparison operator</p><div class="fullcomment"><div class="comment cmt"><p>Greater-than-or-equal-to comparison operator</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&gt;&gt;" data-isabs="false">
      <a id="&gt;&gt;[B, That](B)(BinOp[BitShr, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $greater$greater">&gt;&gt;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.BitShr" class="extype" href="ops/BitShr.html">BitShr</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Bit-shift right (arithmetic)</p><div class="fullcomment"><div class="comment cmt"><p>Bit-shift right (arithmetic)</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#&gt;&gt;&gt;" data-isabs="false">
      <a id="&gt;&gt;&gt;[B, That](B)(BinOp[BitUShr, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $greater$greater$greater">&gt;&gt;&gt;</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.BitUShr" class="extype" href="ops/BitUShr.html">BitUShr</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Bit-shift right (logical)</p><div class="fullcomment"><div class="comment cmt"><p>Bit-shift right (logical)</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#T" data-isabs="false">
      <a id="T:Frame[CX, RX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">T</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[CX, RX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The transpose of the frame (swapping the axes)
</p>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#^" data-isabs="false">
      <a id="^[B, That](B)(BinOp[BitXor, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $up">^</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.BitXor" class="extype" href="ops/BitXor.html">BitXor</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Bit-wise EXCLUSIVE OR</p><div class="fullcomment"><div class="comment cmt"><p>Bit-wise EXCLUSIVE OR</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#align" data-isabs="false">
      <a id="align[U](Frame[RX, CX, U],JoinType,JoinType)(ST[U]):(Frame[RX, CX, T], Frame[RX, CX, U])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">align</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="other">other: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>, <span name="rhow">rhow: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a></span>, <span name="chow">chow: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>)</span><span class="result">: (<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Aligns this frame with another frame, returning the left and right frames aligned
to each others indexes according to the the provided parameters
</p><div class="fullcomment"><div class="comment cmt"><p>Aligns this frame with another frame, returning the left and right frames aligned
to each others indexes according to the the provided parameters
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>Other frame to align with</p></dd><dt class="param">rhow</dt><dd class="cmt"><p>How to perform the join on the row indexes</p></dd><dt class="param">chow</dt><dd class="cmt"><p>How to perform the join on the col indexes
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#apply" data-isabs="false">
      <a id="apply(Array[RX],Array[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="rix">rix: <span name="scala.Array" class="extype">Array</span>[RX]</span>, <span name="cix">cix: <span name="scala.Array" class="extype">Array</span>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Slice from by an array of row keys and an array of col keys</p><div class="fullcomment"><div class="comment cmt"><p>Slice from by an array of row keys and an array of col keys</p></div><dl class="paramcmts block"><dt class="param">rix</dt><dd class="cmt"><p>An array of row keys</p></dd><dt class="param">cix</dt><dd class="cmt"><p>An array of col keys
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#apply" data-isabs="false">
      <a id="apply(Array[RX],Slice[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="rix">rix: <span name="scala.Array" class="extype">Array</span>[RX]</span>, <span name="cix">cix: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Slice frame by array of row keys and a col slice</p><div class="fullcomment"><div class="comment cmt"><p>Slice frame by array of row keys and a col slice</p></div><dl class="paramcmts block"><dt class="param">rix</dt><dd class="cmt"><p>An array of row keys</p></dd><dt class="param">cix</dt><dd class="cmt"><p>A col slice
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#apply" data-isabs="false">
      <a id="apply(Slice[RX],Array[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="rix">rix: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[RX]</span>, <span name="cix">cix: <span name="scala.Array" class="extype">Array</span>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Slice frame by row slice and array of column keys</p><div class="fullcomment"><div class="comment cmt"><p>Slice frame by row slice and array of column keys</p></div><dl class="paramcmts block"><dt class="param">rix</dt><dd class="cmt"><p>A row slice</p></dd><dt class="param">cix</dt><dd class="cmt"><p>An array of column keys
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#apply" data-isabs="false">
      <a id="apply(Slice[RX],Slice[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="rix">rix: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[RX]</span>, <span name="cix">cix: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Slice frame by row and column slice specifiers</p><div class="fullcomment"><div class="comment cmt"><p>Slice frame by row and column slice specifiers</p></div><dl class="paramcmts block"><dt class="param">rix</dt><dd class="cmt"><p>A row slice</p></dd><dt class="param">cix</dt><dd class="cmt"><p>A col slice
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#at" data-isabs="false">
      <a id="at(Slice[Int],Slice[Int]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">at</span><span class="params">(<span name="r">r: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[<span name="scala.Int" class="extype">Int</span>]</span>, <span name="c">c: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[<span name="scala.Int" class="extype">Int</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access a slice of the Frame by Slice parameters</p><div class="fullcomment"><div class="comment cmt"><p>Access a slice of the Frame by Slice parameters</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Slice to apply to rows</p></dd><dt class="param">c</dt><dd class="cmt"><p>Slice to apply to cols
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#at" data-isabs="false">
      <a id="at(Int,Array[Int]):Series[CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">at</span><span class="params">(<span name="r">r: <span name="scala.Int" class="extype">Int</span></span>, <span name="c">c: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Int" class="extype">Int</span>]</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access a slice of the Frame by integer offsets</p><div class="fullcomment"><div class="comment cmt"><p>Access a slice of the Frame by integer offsets</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Integer row offset</p></dd><dt class="param">c</dt><dd class="cmt"><p>Array of col offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#at" data-isabs="false">
      <a id="at(Array[Int],Int):Series[RX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">at</span><span class="params">(<span name="r">r: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Int" class="extype">Int</span>]</span>, <span name="c">c: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access a slice of the Frame by integer offsets</p><div class="fullcomment"><div class="comment cmt"><p>Access a slice of the Frame by integer offsets</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Array of row offsets</p></dd><dt class="param">c</dt><dd class="cmt"><p>Integer col offset
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#at" data-isabs="false">
      <a id="at(Array[Int],Array[Int]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">at</span><span class="params">(<span name="r">r: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Int" class="extype">Int</span>]</span>, <span name="c">c: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Int" class="extype">Int</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access a slice of the Frame by integer offsets</p><div class="fullcomment"><div class="comment cmt"><p>Access a slice of the Frame by integer offsets</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Array of row offsets</p></dd><dt class="param">c</dt><dd class="cmt"><p>Array of col offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#at" data-isabs="false">
      <a id="at(Int,Int):Scalar[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">at</span><span class="params">(<span name="r">r: <span name="scala.Int" class="extype">Int</span></span>, <span name="c">c: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.scalar.Scalar" class="extype" href="scalar/Scalar.html">Scalar</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access a (Scalar-boxed) value from within the Frame</p><div class="fullcomment"><div class="comment cmt"><p>Access a (Scalar-boxed) value from within the Frame</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Integer row offset</p></dd><dt class="param">c</dt><dd class="cmt"><p>Integer col offset
</p></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#col" data-isabs="false">
      <a id="col(Array[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">col</span><span class="params">(<span name="keys">keys: <span name="scala.Array" class="extype">Array</span>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given an array of column keys, slice out the corresponding column(s)</p><div class="fullcomment"><div class="comment cmt"><p>Given an array of column keys, slice out the corresponding column(s)</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>Array of keys
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#col" data-isabs="false">
      <a id="col(Slice[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">col</span><span class="params">(<span name="slice">slice: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given a Slice of type of column key, slice out corresponding column(s)</p><div class="fullcomment"><div class="comment cmt"><p>Given a Slice of type of column key, slice out corresponding column(s)</p></div><dl class="paramcmts block"><dt class="param">slice</dt><dd class="cmt"><p>Slice containing appropriate key bounds
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#col" data-isabs="false">
      <a id="col(CX*):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">col</span><span class="params">(<span name="keys">keys: CX*</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given one or more column keys, slice out the corresponding column(s)</p><div class="fullcomment"><div class="comment cmt"><p>Given one or more column keys, slice out the corresponding column(s)</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>Column key(s) (sequence)
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colAt" data-isabs="false">
      <a id="colAt(Slice[Int]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colAt</span><span class="params">(<span name="slice">slice: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[<span name="scala.Int" class="extype">Int</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame columns specified by a slice</p><div class="fullcomment"><div class="comment cmt"><p>Access frame columns specified by a slice</p></div><dl class="paramcmts block"><dt class="param">slice</dt><dd class="cmt"><p>a slice specifier
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colAt" data-isabs="false">
      <a id="colAt(Array[Int]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colAt</span><span class="params">(<span name="locs">locs: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Int" class="extype">Int</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame columns at a particular integer offsets</p><div class="fullcomment"><div class="comment cmt"><p>Access frame columns at a particular integer offsets</p></div><dl class="paramcmts block"><dt class="param">locs</dt><dd class="cmt"><p>an array of integer offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colAt" data-isabs="false">
      <a id="colAt(Int*):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colAt</span><span class="params">(<span name="locs">locs: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame columns at a particular integer offsets</p><div class="fullcomment"><div class="comment cmt"><p>Access frame columns at a particular integer offsets</p></div><dl class="paramcmts block"><dt class="param">locs</dt><dd class="cmt"><p>a sequence of integer offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colAt" data-isabs="false">
      <a id="colAt(Int):Series[RX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colAt</span><span class="params">(<span name="loc">loc: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame column at a particular integer offset</p><div class="fullcomment"><div class="comment cmt"><p>Access frame column at a particular integer offset</p></div><dl class="paramcmts block"><dt class="param">loc</dt><dd class="cmt"><p>integer offset
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colIx" data-isabs="false">
      <a id="colIx:Index[CX]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">colIx</span><span class="result">: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[CX]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">An index for the columns</p>
    </li><li visbl="pub" name="org.saddle.Frame#colSlice" data-isabs="false">
      <a id="colSlice(Int,Int,Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colSlice</span><span class="params">(<span name="from">from: <span name="scala.Int" class="extype">Int</span></span>, <span name="until">until: <span name="scala.Int" class="extype">Int</span></span>, <span name="stride">stride: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame columns between two integer offsets, [from, until)</p><div class="fullcomment"><div class="comment cmt"><p>Access frame columns between two integer offsets, [from, until)</p></div><dl class="paramcmts block"><dt class="param">from</dt><dd class="cmt"><p>Beginning offset</p></dd><dt class="param">until</dt><dd class="cmt"><p>One past ending offset</p></dd><dt class="param">stride</dt><dd class="cmt"><p>Optional increment between offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colSliceBy" data-isabs="false">
      <a id="colSliceBy(CX,CX,Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colSliceBy</span><span class="params">(<span name="from">from: CX</span>, <span name="to">to: CX</span>, <span name="inclusive">inclusive: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Slice out a set of columns from the frame</p><div class="fullcomment"><div class="comment cmt"><p>Slice out a set of columns from the frame</p></div><dl class="paramcmts block"><dt class="param">from</dt><dd class="cmt"><p>Key from which to begin slicing</p></dd><dt class="param">to</dt><dd class="cmt"><p>Key at which to end slicing</p></dd><dt class="param">inclusive</dt><dd class="cmt"><p>Whether to include 'to' key; true by default
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colSplitAt" data-isabs="false">
      <a id="colSplitAt(Int):(Frame[RX, CX, T], Frame[RX, CX, T])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colSplitAt</span><span class="params">(<span name="c">c: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: (<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Split Frame into two frames at column position c</p><div class="fullcomment"><div class="comment cmt"><p>Split Frame into two frames at column position c</p></div><dl class="paramcmts block"><dt class="param">c</dt><dd class="cmt"><p>Position at which to split Frame
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colSplitBy" data-isabs="false">
      <a id="colSplitBy(CX):(Frame[RX, CX, T], Frame[RX, CX, T])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colSplitBy</span><span class="params">(<span name="k">k: CX</span>)</span><span class="result">: (<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Split Frame into two frames at column key k</p><div class="fullcomment"><div class="comment cmt"><p>Split Frame into two frames at column key k</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key at which to split Frame
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colType" data-isabs="false">
      <a id="colType[U1, U2](ST[U1],ST[U2]):Frame[RX, CX, Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colType</span><span class="tparams">[<span name="U1">U1</span>, <span name="U2">U2</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U1]</span>, <span name="arg1">arg1: ST[U2]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, <span name="scala.Any" class="extype">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract columns from a heterogeneous Frame which match either of the provided
types.</p><div class="fullcomment"><div class="comment cmt"><p>Extract columns from a heterogeneous Frame which match either of the provided
types. The result is a heterogeneous frame consisting of the selected data.</p></div><dl class="paramcmts block"><dt class="tparam">U1</dt><dd class="cmt"><p>First type of columns to extract</p></dd><dt class="tparam">U2</dt><dd class="cmt"><p>Second type of columns to extract
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#colType" data-isabs="false">
      <a id="colType[U](ST[U]):Frame[RX, CX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colType</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract columns from a heterogeneous Frame which match the provided type.</p><div class="fullcomment"><div class="comment cmt"><p>Extract columns from a heterogeneous Frame which match the provided type.
The result is a homogeneous frame consisting of the selected data.</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>The type of columns to extract
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#concat" data-isabs="false">
      <a id="concat[U, V](Frame[RX, CX, U],JoinType)(Promoter[T, U, V],ST[U],ST[V]):Frame[RX, CX, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">concat</span><span class="tparams">[<span name="U">U</span>, <span name="V">V</span>]</span><span class="params">(<span name="other">other: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pro">pro: <a name="org.saddle.util.Concat.Promoter" class="extype" href="util/Concat$$Promoter.html">Promoter</a>[T, U, V]</span>, <span name="mu">mu: ST[U]</span>, <span name="md">md: ST[V]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Concatenate two Frame instances together (vertically) whose indexes share the same type
of elements, and where there exists some way to join the values of the Frames.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenate two Frame instances together (vertically) whose indexes share the same type
of elements, and where there exists some way to join the values of the Frames. For
instance, Frame[X, Y, Double] <code>concat</code> Frame[X, Y, Int] will promote Int to Double as
a result of the implicit existence of a Promoter[Double, Int, Double] instance.
The resulting row index will simply be the concatenation of the input row indexes, and
the column index will be the joint index (with join type specified as argument).
</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>type of other Frame values</p></dd><dt class="tparam">V</dt><dd class="cmt"><p>type of resulting Frame values
</p></dd><dt class="param">other</dt><dd class="cmt"><p>Frame[RX, CX, U] to concat</p></dd><dt class="param">pro</dt><dd class="cmt"><p>Implicit evidence of Promoter</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#cshift" data-isabs="false">
      <a id="cshift(Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cshift</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See shift; operates col-wise
</p>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#dot" data-isabs="false">
      <a id="dot[B, That](B)(BinOp[InnerProd, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dot</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.InnerProd" class="extype" href="ops/InnerProd.html">InnerProd</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Dot (inner) product</p><div class="fullcomment"><div class="comment cmt"><p>Dot (inner) product</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#dropNA" data-isabs="false">
      <a id="dropNA:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropNA</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return Frame excluding any of those columns which have an NA value
</p>
    </li><li visbl="pub" name="org.saddle.Frame#emptyCol" data-isabs="false">
      <a id="emptyCol:Series[RX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">emptyCol</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return empty series of type equivalent to a column of frame</p>
    </li><li visbl="pub" name="org.saddle.Frame#emptyRow" data-isabs="false">
      <a id="emptyRow:Series[CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">emptyRow</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return empty series of type equivalent to a row of frame</p>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="other">other: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.Frame" class="extype" href="">Frame</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#filter" data-isabs="false">
      <a id="filter((Series[RX, T]) ⇒ Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="pred">pred: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return Frame whose columns satisfy a predicate function operating on that
column</p><div class="fullcomment"><div class="comment cmt"><p>Return Frame whose columns satisfy a predicate function operating on that
column</p></div><dl class="paramcmts block"><dt class="param">pred</dt><dd class="cmt"><p>Predicate function from Series[RX, T] =&gt; Boolean
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#filterIx" data-isabs="false">
      <a id="filterIx((CX) ⇒ Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filterIx</span><span class="params">(<span name="pred">pred: (CX) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return Frame whose columns satisfy a predicate function operating on the
column index</p><div class="fullcomment"><div class="comment cmt"><p>Return Frame whose columns satisfy a predicate function operating on the
column index</p></div><dl class="paramcmts block"><dt class="param">pred</dt><dd class="cmt"><p>Predicate function from CX =&gt; Boolean
</p></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#first" data-isabs="false">
      <a id="first(RX):Series[CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">first</span><span class="params">(<span name="k">k: RX</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract first row matching a particular key
</p><div class="fullcomment"><div class="comment cmt"><p>Extract first row matching a particular key
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key to match
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#firstCol" data-isabs="false">
      <a id="firstCol(CX):Series[RX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">firstCol</span><span class="params">(<span name="k">k: CX</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract first col matching a particular key
</p><div class="fullcomment"><div class="comment cmt"><p>Extract first col matching a particular key
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key to match
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#groupBy" data-isabs="false">
      <a id="groupBy[Y](Index[Y])(ST[Y],ORD[Y]):FrameGrouper[Y, RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupBy</span><span class="tparams">[<span name="Y">Y</span>]</span><span class="params">(<span name="ix">ix: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[Y]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[Y]</span>, <span name="arg1">arg1: ORD[Y]</span>)</span><span class="result">: <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a>[Y, RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Construct a <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a> with which further computations, such
as combine or transform, may be performed.</p><div class="fullcomment"><div class="comment cmt"><p>Construct a <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a> with which further computations, such
as combine or transform, may be performed. The groups are constructed from the keys of
the provided index, with each unique key corresponding to a group.</p></div><dl class="paramcmts block"><dt class="tparam">Y</dt><dd class="cmt"><p>Type of elements of ix
</p></dd><dt class="param">ix</dt><dd class="cmt"><p>Index with which to perform grouping</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#groupBy" data-isabs="false">
      <a id="groupBy[Y]((RX) ⇒ Y)(ST[Y],ORD[Y]):FrameGrouper[Y, RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupBy</span><span class="tparams">[<span name="Y">Y</span>]</span><span class="params">(<span name="fn">fn: (RX) ⇒ Y</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[Y]</span>, <span name="arg1">arg1: ORD[Y]</span>)</span><span class="result">: <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a>[Y, RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Construct a <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a> with which further computations, such
as combine or transform, may be performed.</p><div class="fullcomment"><div class="comment cmt"><p>Construct a <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a> with which further computations, such
as combine or transform, may be performed. The groups are constructed from the result
of the function applied to the keys of the row index; each unique result of calling the
function on elements of the row index corresponds to a group.</p></div><dl class="paramcmts block"><dt class="tparam">Y</dt><dd class="cmt"><p>Type of function codomain
</p></dd><dt class="param">fn</dt><dd class="cmt"><p>Function from RX =&gt; Y</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#groupBy" data-isabs="false">
      <a id="groupBy:FrameGrouper[RX, RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupBy</span><span class="result">: <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a>[RX, RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Construct a <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a> with which further computations, such
as combine or transform, may be performed.</p><div class="fullcomment"><div class="comment cmt"><p>Construct a <a name="org.saddle.groupby.FrameGrouper" class="extype" href="groupby/FrameGrouper.html">FrameGrouper</a> with which further computations, such
as combine or transform, may be performed. The groups are constructed from the keys of
the row index, with each unique key corresponding to a group.
</p></div></div>
    </li><li visbl="pub" name="org.saddle.Frame#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.Frame" class="extype" href="">Frame</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#head" data-isabs="false">
      <a id="head(Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">head</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract first n rows
</p><div class="fullcomment"><div class="comment cmt"><p>Extract first n rows
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>number of rows to extract
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#headCol" data-isabs="false">
      <a id="headCol(Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headCol</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract first n columns
</p><div class="fullcomment"><div class="comment cmt"><p>Extract first n columns
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>number of columns to extract
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#isEmpty" data-isabs="false">
      <a id="isEmpty:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isEmpty</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns true if there are no values in the Frame
</p>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#join" data-isabs="false">
      <a id="join(org.saddle.Frame[RX, _, T],JoinType):Frame[RX, Int, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">join</span><span class="params">(<span name="other">other: org.saddle.Frame[RX, _, T]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, <span name="scala.Int" class="extype">Int</span>, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Perform a join with another Frame[RX, CX, T] according to the row index.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a join with another Frame[RX, CX, T] according to the row index. The <code>how</code>
argument dictates how the join is to be performed:</p><ul><li>Left org.saddle.index.LeftJoin</li><li>Right org.saddle.index.RightJoin</li><li>Inner org.saddle.index.InnerJoin</li><li>Outer org.saddle.index.OuterJoin</li></ul><p>The result is a Frame whose row index is the result of the join, and whose column
index has been reset to [0, M + N), where M is the number of columns in the left
frame and N in the right, and whose values are sourced from the original Frames.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>Frame to join with</p></dd><dt class="param">how</dt><dd class="cmt"><p>How to perform the join
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#joinAny" data-isabs="false">
      <a id="joinAny(org.saddle.Frame[RX, _, _],JoinType):Frame[RX, Int, Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">joinAny</span><span class="params">(<span name="other">other: org.saddle.Frame[RX, _, _]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, <span name="scala.Int" class="extype">Int</span>, <span name="scala.Any" class="extype">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Same as join, but the values of Frame to join with may be of type Any, so that the
resulting Frame may be heterogeneous in its column types.</p>
    </li><li visbl="pub" name="org.saddle.Frame#joinAnyS" data-isabs="false">
      <a id="joinAnyS(org.saddle.Series[RX, _],JoinType):Frame[RX, Int, Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">joinAnyS</span><span class="params">(<span name="other">other: org.saddle.Series[RX, _]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, <span name="scala.Int" class="extype">Int</span>, <span name="scala.Any" class="extype">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Same as joinS, but the values of Series to join with may be of type Any, so that the
resulting Frame may be heterogeneous in its column types.</p>
    </li><li visbl="pub" name="org.saddle.Frame#joinMap" data-isabs="false">
      <a id="joinMap[U, V](Frame[RX, CX, U],JoinType,JoinType)((T, U) ⇒ V)(ST[U],ST[V]):Frame[RX, CX, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">joinMap</span><span class="tparams">[<span name="U">U</span>, <span name="V">V</span>]</span><span class="params">(<span name="other">other: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>, <span name="rhow">rhow: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a></span>, <span name="chow">chow: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a></span>)</span><span class="params">(<span name="f">f: (T, U) ⇒ V</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>, <span name="arg1">arg1: ST[V]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Joins two frames along both their indexes and applies a function to each pair
of values; when either value is NA, the result of the function is forced to be NA.</p><div class="fullcomment"><div class="comment cmt"><p>Joins two frames along both their indexes and applies a function to each pair
of values; when either value is NA, the result of the function is forced to be NA.</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>The type of other frame values</p></dd><dt class="tparam">V</dt><dd class="cmt"><p>The result type of the function
</p></dd><dt class="param">other</dt><dd class="cmt"><p>Other Frame</p></dd><dt class="param">rhow</dt><dd class="cmt"><p>The type of join to effect on the rows</p></dd><dt class="param">chow</dt><dd class="cmt"><p>The type of join to effect on the cols</p></dd><dt class="param">f</dt><dd class="cmt"><p>The function to apply</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#joinS" data-isabs="false">
      <a id="joinS(Series[RX, T],JoinType):Frame[RX, Int, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">joinS</span><span class="params">(<span name="other">other: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, <span name="scala.Int" class="extype">Int</span>, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Perform a join with another Series[RX, T] according to the row index.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a join with another Series[RX, T] according to the row index. The <code>how</code>
argument dictates how the join is to be performed:</p><ul><li>Left org.saddle.index.LeftJoin</li><li>Right org.saddle.index.RightJoin</li><li>Inner org.saddle.index.InnerJoin</li><li>Outer org.saddle.index.OuterJoin</li></ul><p>The result is a Frame whose row index is the result of the join, and whose column
index has been reset to [0, numcols], and whose values are sourced from the original
Frame and Series.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>Series to join with</p></dd><dt class="param">how</dt><dd class="cmt"><p>How to perform the join
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#last" data-isabs="false">
      <a id="last(RX):Series[CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">last</span><span class="params">(<span name="k">k: RX</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract last row matching a particular key
</p><div class="fullcomment"><div class="comment cmt"><p>Extract last row matching a particular key
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key to match
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#lastCol" data-isabs="false">
      <a id="lastCol(CX):Series[RX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lastCol</span><span class="params">(<span name="k">k: CX</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract first col matching a particular key
</p><div class="fullcomment"><div class="comment cmt"><p>Extract first col matching a particular key
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key to match
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#mapColIndex" data-isabs="false">
      <a id="mapColIndex[Y]((CX) ⇒ Y)(ST[Y],ORD[Y]):Frame[RX, Y, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapColIndex</span><span class="tparams">[<span name="Y">Y</span>]</span><span class="params">(<span name="fn">fn: (CX) ⇒ Y</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[Y]</span>, <span name="arg1">arg1: ORD[Y]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, Y, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Map a function over the col index, resulting in a new Frame
</p><div class="fullcomment"><div class="comment cmt"><p>Map a function over the col index, resulting in a new Frame
</p></div><dl class="paramcmts block"><dt class="tparam">Y</dt><dd class="cmt"><p>Result type of index, ie Index[Y]
</p></dd><dt class="param">fn</dt><dd class="cmt"><p>The function CX =&gt; Y with which to map</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#mapRowIndex" data-isabs="false">
      <a id="mapRowIndex[Y]((RX) ⇒ Y)(ST[Y],ORD[Y]):Frame[Y, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapRowIndex</span><span class="tparams">[<span name="Y">Y</span>]</span><span class="params">(<span name="fn">fn: (RX) ⇒ Y</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[Y]</span>, <span name="arg1">arg1: ORD[Y]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[Y, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Map a function over the row index, resulting in a new Frame
</p><div class="fullcomment"><div class="comment cmt"><p>Map a function over the row index, resulting in a new Frame
</p></div><dl class="paramcmts block"><dt class="tparam">Y</dt><dd class="cmt"><p>Result type of index, ie Index[Y]
</p></dd><dt class="param">fn</dt><dd class="cmt"><p>The function RX =&gt; Y with which to map</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#mapValues" data-isabs="false">
      <a id="mapValues[U]((T) ⇒ U)(ST[U]):Frame[RX, CX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapValues</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (T) ⇒ U</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Map over the values of the Frame.</p><div class="fullcomment"><div class="comment cmt"><p>Map over the values of the Frame. Applies a function to each (non-na) value in the frame,
returning a new frame whose indices remain the same.
</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>The type of the resulting values
</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function from T to U</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#mapVec" data-isabs="false">
      <a id="mapVec[U]((Vec[T]) ⇒ Vec[U])(ST[U]):Frame[RX, CX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapVec</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Vec" class="extype" href="Vec.html">Vec</a>[T]) ⇒ <a name="org.saddle.Vec" class="extype" href="Vec.html">Vec</a>[U]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Map a function over each column vector and collect the results into a Frame respecting
the original indexes.</p><div class="fullcomment"><div class="comment cmt"><p>Map a function over each column vector and collect the results into a Frame respecting
the original indexes.</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>Type of result Vec of the function
</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function acting on Vec[T] and producing another Vec</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#mask" data-isabs="false">
      <a id="mask(Vec[Boolean]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mask</span><span class="params">(<span name="m">m: <a name="org.saddle.Vec" class="extype" href="Vec.html">Vec</a>[<span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose columns follow the rule that, wherever the mask Vec is true,
the column value is masked with NA</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose columns follow the rule that, wherever the mask Vec is true,
the column value is masked with NA</p></div><dl class="paramcmts block"><dt class="param">m</dt><dd class="cmt"><p>Mask Vec[Boolean]
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#mask" data-isabs="false">
      <a id="mask((T) ⇒ Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mask</span><span class="params">(<span name="f">f: (T) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame that, whenever the mask predicate function evaluates to
true on a value, is masked with NA</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame that, whenever the mask predicate function evaluates to
true on a value, is masked with NA</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Function from T to Boolean
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#melt" data-isabs="false">
      <a id="melt[W](Melter[RX, CX, W]):Series[W, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">melt</span><span class="tparams">[<span name="W">W</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="melter">melter: <a name="org.saddle.index.Melter" class="extype" href="index/Melter.html">Melter</a>[RX, CX, W]</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[W, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Melt stacks the row index of arity N with the column index of arity M to form a result index
of arity N + M, producing a 1D Series whose values are from the original Frame as indexed by
the corresponding keys.</p><div class="fullcomment"><div class="comment cmt"><p>Melt stacks the row index of arity N with the column index of arity M to form a result index
of arity N + M, producing a 1D Series whose values are from the original Frame as indexed by
the corresponding keys.</p><p>For example, given:</p><pre>
  Frame(<span class="num">1</span> -&gt; Series(<span class="lit">'a'</span> -&gt; <span class="num">1</span>, <span class="lit">'b'</span> -&gt; <span class="num">3</span>), <span class="num">2</span> -&gt; Series(<span class="lit">'a'</span> -&gt; <span class="num">2</span>, <span class="lit">'b'</span> -&gt; <span class="num">4</span>)).melt
</pre><p>produces:</p><pre>
res0: org.saddle.Series[(<span class="std">Char</span>, <span class="std">Int</span>),<span class="std">Int</span>] =
[<span class="num">4</span> x <span class="num">1</span>]
 a <span class="num">1</span> <span class="kw">=&gt;</span> <span class="num">1</span>
   <span class="num">2</span> <span class="kw">=&gt;</span> <span class="num">2</span>
 b <span class="num">1</span> <span class="kw">=&gt;</span> <span class="num">3</span>
   <span class="num">2</span> <span class="kw">=&gt;</span> <span class="num">4</span>
</pre></div><dl class="paramcmts block"><dt class="tparam">W</dt><dd class="cmt"><p>Output type (tuple of arity N + M)
</p></dd><dt class="param">melter</dt><dd class="cmt"><p>Implicit evidence for a Melter for the two indexes</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#numCols" data-isabs="false">
      <a id="numCols:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">numCols</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Number of cols in the Frame
</p>
    </li><li visbl="pub" name="org.saddle.Frame#numRows" data-isabs="false">
      <a id="numRows:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">numRows</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Number of rows in the Frame
</p>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#outer" data-isabs="false">
      <a id="outer[B, That](B)(BinOp[OuterProd, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">outer</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.OuterProd" class="extype" href="ops/OuterProd.html">OuterProd</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Outer product</p><div class="fullcomment"><div class="comment cmt"><p>Outer product</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#pad" data-isabs="false">
      <a id="pad:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pad</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">In each column, replaces all NA values for which there is a non-NA value at
a prior offset with the corresponding most-recent, non-NA value.</p><div class="fullcomment"><div class="comment cmt"><p>In each column, replaces all NA values for which there is a non-NA value at
a prior offset with the corresponding most-recent, non-NA value. See Vec.pad
</p></div></div>
    </li><li visbl="pub" name="org.saddle.Frame#padAtMost" data-isabs="false">
      <a id="padAtMost(Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">padAtMost</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Same as above, but limits the number of observations padded.</p><div class="fullcomment"><div class="comment cmt"><p>Same as above, but limits the number of observations padded. See Vec.padAtMost
</p></div></div>
    </li><li visbl="pub" name="org.saddle.Frame#print" data-isabs="false">
      <a id="print(Int,Int,OutputStream):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">print</span><span class="params">(<span name="nrows">nrows: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">10</span></span>, <span name="ncols">ncols: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">10</span></span>, <span name="stream">stream: <span name="java.io.OutputStream" class="extype">OutputStream</span> = <span class="symbol"><span class="name"><a href="../../java/lang/package.html">System.out</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pretty-printer for Frame, which simply outputs the result of stringify.</p><div class="fullcomment"><div class="comment cmt"><p>Pretty-printer for Frame, which simply outputs the result of stringify.</p></div><dl class="paramcmts block"><dt class="param">nrows</dt><dd class="cmt"><p>Number of rows to display</p></dd><dt class="param">ncols</dt><dd class="cmt"><p>Number of cols to display
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#raw" data-isabs="false">
      <a id="raw(Int,Int):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">raw</span><span class="params">(<span name="r">r: <span name="scala.Int" class="extype">Int</span></span>, <span name="c">c: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access the raw (unboxed) value at an offset within the Frame</p><div class="fullcomment"><div class="comment cmt"><p>Access the raw (unboxed) value at an offset within the Frame</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Integer row offset</p></dd><dt class="param">c</dt><dd class="cmt"><p>Integer col offset
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rconcat" data-isabs="false">
      <a id="rconcat[U, V](Frame[RX, CX, U],JoinType)(Promoter[T, U, V],ST[U],ST[V]):Frame[RX, CX, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rconcat</span><span class="tparams">[<span name="U">U</span>, <span name="V">V</span>]</span><span class="params">(<span name="other">other: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="wd1">wd1: <a name="org.saddle.util.Concat.Promoter" class="extype" href="util/Concat$$Promoter.html">Promoter</a>[T, U, V]</span>, <span name="mu">mu: ST[U]</span>, <span name="md">md: ST[V]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See concat; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rdropNA" data-isabs="false">
      <a id="rdropNA:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rdropNA</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See dropNA; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#reduce" data-isabs="false">
      <a id="reduce[U]((Series[RX, T]) ⇒ U)(ST[U]):Series[CX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]) ⇒ U</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Apply a function to each column series which results in a single value, and return the
series of results indexed by original column index.</p><div class="fullcomment"><div class="comment cmt"><p>Apply a function to each column series which results in a single value, and return the
series of results indexed by original column index.</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>The output type of the function
</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function taking a column (series) to a value</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#reindex" data-isabs="false">
      <a id="reindex(Index[RX],Index[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reindex</span><span class="params">(<span name="rix">rix: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[RX]</span>, <span name="cix">cix: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose indexes are formed from the provided arguments, and whose values
are derived from the original Frame.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose indexes are formed from the provided arguments, and whose values
are derived from the original Frame. Keys in the provided indices which do not map to
existing values will map to NA in the new Frame.</p></div><dl class="paramcmts block"><dt class="param">rix</dt><dd class="cmt"><p>Sequence of keys to be the row index of the result Frame</p></dd><dt class="param">cix</dt><dd class="cmt"><p>Sequence of keys to be the col index of the result Frame
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#reindexCol" data-isabs="false">
      <a id="reindexCol(Index[CX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reindexCol</span><span class="params">(<span name="cix">cix: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[CX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose col index is formed of the provided argument, and whose values
are derived from the original Frame.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose col index is formed of the provided argument, and whose values
are derived from the original Frame.</p></div><dl class="paramcmts block"><dt class="param">cix</dt><dd class="cmt"><p>Sequence of keys to be the col index of the result Frame
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#reindexRow" data-isabs="false">
      <a id="reindexRow(Index[RX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reindexRow</span><span class="params">(<span name="rix">rix: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[RX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose row index is formed of the provided argument, and whose values
are derived from the original Frame.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose row index is formed of the provided argument, and whose values
are derived from the original Frame.</p></div><dl class="paramcmts block"><dt class="param">rix</dt><dd class="cmt"><p>Sequence of keys to be the row index of the result Frame
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#resetColIndex" data-isabs="false">
      <a id="resetColIndex:Frame[RX, Int, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resetColIndex</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, <span name="scala.Int" class="extype">Int</span>, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose values are the same, but whose col index has been changed
to the bound [0, numCols - 1), as in an array.</p>
    </li><li visbl="pub" name="org.saddle.Frame#resetRowIndex" data-isabs="false">
      <a id="resetRowIndex:Frame[Int, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resetRowIndex</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[<span name="scala.Int" class="extype">Int</span>, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose values are the same, but whose row index has been changed
to the bound [0, numRows - 1), as in an array.</p>
    </li><li visbl="pub" name="org.saddle.Frame#rfilter" data-isabs="false">
      <a id="rfilter((Series[CX, T]) ⇒ Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rfilter</span><span class="params">(<span name="pred">pred: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See filter; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rfilterIx" data-isabs="false">
      <a id="rfilterIx((RX) ⇒ Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rfilterIx</span><span class="params">(<span name="pred">pred: (RX) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See filterIx; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rjoin" data-isabs="false">
      <a id="rjoin(org.saddle.Frame[_, CX, T],JoinType):Frame[Int, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rjoin</span><span class="params">(<span name="other">other: org.saddle.Frame[_, CX, T]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[<span name="scala.Int" class="extype">Int</span>, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See join; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rjoinAny" data-isabs="false">
      <a id="rjoinAny(org.saddle.Frame[_, CX, _],JoinType):Frame[Int, CX, Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rjoinAny</span><span class="params">(<span name="other">other: org.saddle.Frame[_, CX, _]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[<span name="scala.Int" class="extype">Int</span>, CX, <span name="scala.Any" class="extype">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See joinAny; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rjoinAnyS" data-isabs="false">
      <a id="rjoinAnyS(org.saddle.Series[CX, _],JoinType):Frame[Int, CX, Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rjoinAnyS</span><span class="params">(<span name="other">other: org.saddle.Series[CX, _]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[<span name="scala.Int" class="extype">Int</span>, CX, <span name="scala.Any" class="extype">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See joinAnyS; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rjoinS" data-isabs="false">
      <a id="rjoinS(Series[CX, T],JoinType):Frame[Int, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rjoinS</span><span class="params">(<span name="other">other: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]</span>, <span name="how">how: <a name="org.saddle.index.JoinType" class="extype" href="index/JoinType.html">JoinType</a> = <span class="symbol"><span class="name"><a href="index/package.html">LeftJoin</a></span></span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[<span name="scala.Int" class="extype">Int</span>, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See joinS; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rmapVec" data-isabs="false">
      <a id="rmapVec[U]((Vec[T]) ⇒ Vec[U])(ST[U]):Frame[RX, CX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rmapVec</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Vec" class="extype" href="Vec.html">Vec</a>[T]) ⇒ <a name="org.saddle.Vec" class="extype" href="Vec.html">Vec</a>[U]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See mapVec; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rmask" data-isabs="false">
      <a id="rmask(Vec[Boolean]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rmask</span><span class="params">(<span name="b">b: <a name="org.saddle.Vec" class="extype" href="Vec.html">Vec</a>[<span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See mask; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rmask" data-isabs="false">
      <a id="rmask((T) ⇒ Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rmask</span><span class="params">(<span name="f">f: (T) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See mask; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rolling" data-isabs="false">
      <a id="rolling[B](Int,(Series[RX, T]) ⇒ B)(ST[B]):Frame[RX, CX, B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rolling</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="winSz">winSz: <span name="scala.Int" class="extype">Int</span></span>, <span name="f">f: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[B]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Produce a Frame each of whose columns are the result of executing a function
on a sliding window of each column series.</p><div class="fullcomment"><div class="comment cmt"><p>Produce a Frame each of whose columns are the result of executing a function
on a sliding window of each column series.</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>Result type of function
</p></dd><dt class="param">winSz</dt><dd class="cmt"><p>Window size</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function Series[X, T] =&gt; B to operate on sliding window</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rollingFtoS" data-isabs="false">
      <a id="rollingFtoS[B](Int,(Frame[RX, CX, T]) ⇒ B)(ST[B]):Series[RX, B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rollingFtoS</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="winSz">winSz: <span name="scala.Int" class="extype">Int</span></span>, <span name="f">f: (<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[B]</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a Series by rolling over winSz number of rows of the Frame at a
time, and applying a function that takes those rows to a single value.</p><div class="fullcomment"><div class="comment cmt"><p>Create a Series by rolling over winSz number of rows of the Frame at a
time, and applying a function that takes those rows to a single value.
</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>Result element type of Series
</p></dd><dt class="param">winSz</dt><dd class="cmt"><p>Window size to roll with</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function taking the (sub) frame to B</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#row" data-isabs="false">
      <a id="row(Array[RX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">row</span><span class="params">(<span name="keys">keys: <span name="scala.Array" class="extype">Array</span>[RX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given an array of row keys, slice out the corresponding row(s)</p><div class="fullcomment"><div class="comment cmt"><p>Given an array of row keys, slice out the corresponding row(s)</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>Array of keys
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#row" data-isabs="false">
      <a id="row(Slice[RX]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">row</span><span class="params">(<span name="slice">slice: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[RX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given a Slice of type of row key, slice out corresponding row(s)</p><div class="fullcomment"><div class="comment cmt"><p>Given a Slice of type of row key, slice out corresponding row(s)</p></div><dl class="paramcmts block"><dt class="param">slice</dt><dd class="cmt"><p>Slice containing appropriate key bounds
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#row" data-isabs="false">
      <a id="row(RX*):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">row</span><span class="params">(<span name="keys">keys: RX*</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given one or more row keys, slice out the corresponding row(s)</p><div class="fullcomment"><div class="comment cmt"><p>Given one or more row keys, slice out the corresponding row(s)</p></div><dl class="paramcmts block"><dt class="param">keys</dt><dd class="cmt"><p>Row key(s) (sequence)
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowAt" data-isabs="false">
      <a id="rowAt(Slice[Int]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowAt</span><span class="params">(<span name="slice">slice: <a name="org.saddle.index.Slice" class="extype" href="index/Slice.html">Slice</a>[<span name="scala.Int" class="extype">Int</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame rows specified by a slice</p><div class="fullcomment"><div class="comment cmt"><p>Access frame rows specified by a slice</p></div><dl class="paramcmts block"><dt class="param">slice</dt><dd class="cmt"><p>a slice specifier
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowAt" data-isabs="false">
      <a id="rowAt(Array[Int]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowAt</span><span class="params">(<span name="locs">locs: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Int" class="extype">Int</span>]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame rows at a particular integer offsets</p><div class="fullcomment"><div class="comment cmt"><p>Access frame rows at a particular integer offsets</p></div><dl class="paramcmts block"><dt class="param">locs</dt><dd class="cmt"><p>an array of integer offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowAt" data-isabs="false">
      <a id="rowAt(Int*):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowAt</span><span class="params">(<span name="locs">locs: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame rows at a particular integer offsets</p><div class="fullcomment"><div class="comment cmt"><p>Access frame rows at a particular integer offsets</p></div><dl class="paramcmts block"><dt class="param">locs</dt><dd class="cmt"><p>a sequence of integer offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowAt" data-isabs="false">
      <a id="rowAt(Int):Series[CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowAt</span><span class="params">(<span name="loc">loc: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame row at a particular integer offset</p><div class="fullcomment"><div class="comment cmt"><p>Access frame row at a particular integer offset</p></div><dl class="paramcmts block"><dt class="param">loc</dt><dd class="cmt"><p>integer offset
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowIx" data-isabs="false">
      <a id="rowIx:Index[RX]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">rowIx</span><span class="result">: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[RX]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">An index for the rows</p>
    </li><li visbl="pub" name="org.saddle.Frame#rowSlice" data-isabs="false">
      <a id="rowSlice(Int,Int,Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowSlice</span><span class="params">(<span name="from">from: <span name="scala.Int" class="extype">Int</span></span>, <span name="until">until: <span name="scala.Int" class="extype">Int</span></span>, <span name="stride">stride: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Access frame rows between two integer offsets, [from, until)</p><div class="fullcomment"><div class="comment cmt"><p>Access frame rows between two integer offsets, [from, until)</p></div><dl class="paramcmts block"><dt class="param">from</dt><dd class="cmt"><p>Beginning offset</p></dd><dt class="param">until</dt><dd class="cmt"><p>One past ending offset</p></dd><dt class="param">stride</dt><dd class="cmt"><p>Optional increment between offsets
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowSliceBy" data-isabs="false">
      <a id="rowSliceBy(RX,RX,Boolean):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowSliceBy</span><span class="params">(<span name="from">from: RX</span>, <span name="to">to: RX</span>, <span name="inclusive">inclusive: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Slice out a set of rows from the frame</p><div class="fullcomment"><div class="comment cmt"><p>Slice out a set of rows from the frame</p></div><dl class="paramcmts block"><dt class="param">from</dt><dd class="cmt"><p>Key from which to begin slicing</p></dd><dt class="param">to</dt><dd class="cmt"><p>Key at which to end slicing</p></dd><dt class="param">inclusive</dt><dd class="cmt"><p>Whether to include 'to' key; true by default
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowSplitAt" data-isabs="false">
      <a id="rowSplitAt(Int):(Frame[RX, CX, T], Frame[RX, CX, T])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowSplitAt</span><span class="params">(<span name="r">r: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: (<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Split Frame into two frames at row position r</p><div class="fullcomment"><div class="comment cmt"><p>Split Frame into two frames at row position r</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Position at which to split Frame
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rowSplitBy" data-isabs="false">
      <a id="rowSplitBy(RX):(Frame[RX, CX, T], Frame[RX, CX, T])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rowSplitBy</span><span class="params">(<span name="k">k: RX</span>)</span><span class="result">: (<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Split Frame into two frames at row key k</p><div class="fullcomment"><div class="comment cmt"><p>Split Frame into two frames at row key k</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key at which to split Frame
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#rreduce" data-isabs="false">
      <a id="rreduce[U]((Series[CX, T]) ⇒ U)(ST[U]):Series[RX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rreduce</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]) ⇒ U</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>)</span><span class="result">: <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See reduce; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rsqueeze" data-isabs="false">
      <a id="rsqueeze:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rsqueeze</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See squeeze; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rtransform" data-isabs="false">
      <a id="rtransform[U, SX]((Series[CX, T]) ⇒ Series[SX, U])(ST[U],ST[SX],ORD[SX]):Frame[RX, SX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rtransform</span><span class="tparams">[<span name="U">U</span>, <span name="SX">SX</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]) ⇒ <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[SX, U]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>, <span name="arg1">arg1: ST[SX]</span>, <span name="arg2">arg2: ORD[SX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, SX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See transform; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#rwhere" data-isabs="false">
      <a id="rwhere(org.saddle.Series[_, Boolean]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rwhere</span><span class="params">(<span name="pred">pred: org.saddle.Series[_, Boolean]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">See where; operates row-wise
</p>
    </li><li visbl="pub" name="org.saddle.Frame#setColIndex" data-isabs="false">
      <a id="setColIndex[Y](Index[Y])(ST[Y],ORD[Y]):Frame[RX, Y, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setColIndex</span><span class="tparams">[<span name="Y">Y</span>]</span><span class="params">(<span name="newIx">newIx: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[Y]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[Y]</span>, <span name="arg1">arg1: ORD[Y]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, Y, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame using the current values but with the new col index.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame using the current values but with the new col index. Positions
of the values do not change. Length of new index must be equal to number of cols.</p></div><dl class="paramcmts block"><dt class="tparam">Y</dt><dd class="cmt"><p>Type of elements of new Index
</p></dd><dt class="param">newIx</dt><dd class="cmt"><p>A new Index</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#setRowIndex" data-isabs="false">
      <a id="setRowIndex[Y](Index[Y])(ST[Y],ORD[Y]):Frame[Y, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setRowIndex</span><span class="tparams">[<span name="Y">Y</span>]</span><span class="params">(<span name="newIx">newIx: <a name="org.saddle.Index" class="extype" href="Index.html">Index</a>[Y]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[Y]</span>, <span name="arg1">arg1: ORD[Y]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[Y, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame using the current values but with the new row index.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame using the current values but with the new row index. Positions
of the values do not change. Length of new index must be equal to number of rows.</p></div><dl class="paramcmts block"><dt class="tparam">Y</dt><dd class="cmt"><p>Type of elements of new Index
</p></dd><dt class="param">newIx</dt><dd class="cmt"><p>A new Index</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#shift" data-isabs="false">
      <a id="shift(Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shift</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Shift the sequence of values relative to the row index by some offset,
dropping those values which no longer associate with a key, and having
those keys which no longer associate to a value instead map to NA.</p><div class="fullcomment"><div class="comment cmt"><p>Shift the sequence of values relative to the row index by some offset,
dropping those values which no longer associate with a key, and having
those keys which no longer associate to a value instead map to NA.</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>Number to shift
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#sortedCIx" data-isabs="false">
      <a id="sortedCIx:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortedCIx</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose cols are sorted according to the col
index keys
</p>
    </li><li visbl="pub" name="org.saddle.Frame#sortedCols" data-isabs="false">
      <a id="sortedCols(Int*)(ORD[T]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortedCols</span><span class="params">(<span name="locs">locs: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: ORD[T]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose cols are sorted primarily on the values
in the first row specified in the argument list, and then on
the values in the next row, etc.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose cols are sorted primarily on the values
in the first row specified in the argument list, and then on
the values in the next row, etc.</p></div><dl class="paramcmts block"><dt class="param">locs</dt><dd class="cmt"><p>Location of rows containing values to sort on
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#sortedColsBy" data-isabs="false">
      <a id="sortedColsBy[Q]((Series[RX, T]) ⇒ Q)(ORD[Q]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortedColsBy</span><span class="tparams">[<span name="Q">Q</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]) ⇒ Q</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ORD[Q]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose cols are sorted by the result of a function
acting on each col.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose cols are sorted by the result of a function
acting on each col.</p></div><dl class="paramcmts block"><dt class="tparam">Q</dt><dd class="cmt"><p>Result type of the function
</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function from a single col (represented as series) to a value having an
         ordering</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#sortedRIx" data-isabs="false">
      <a id="sortedRIx:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortedRIx</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose rows are sorted according to the row
index keys
</p>
    </li><li visbl="pub" name="org.saddle.Frame#sortedRows" data-isabs="false">
      <a id="sortedRows(Int*)(ORD[T]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortedRows</span><span class="params">(<span name="locs">locs: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: ORD[T]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose rows are sorted primarily on the values
in the first column specified in the argument list, and then on
the values in the next column, etc.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose rows are sorted primarily on the values
in the first column specified in the argument list, and then on
the values in the next column, etc.</p></div><dl class="paramcmts block"><dt class="param">locs</dt><dd class="cmt"><p>Location of columns containing values to sort on
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#sortedRowsBy" data-isabs="false">
      <a id="sortedRowsBy[Q]((Series[CX, T]) ⇒ Q)(ORD[Q]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortedRowsBy</span><span class="tparams">[<span name="Q">Q</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T]) ⇒ Q</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ORD[Q]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a new Frame whose rows are sorted by the result of a function
acting on each row.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new Frame whose rows are sorted by the result of a function
acting on each row.</p></div><dl class="paramcmts block"><dt class="tparam">Q</dt><dd class="cmt"><p>Result type of the function
</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function from a single row (represented as series) to a value having an
         ordering</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#squeeze" data-isabs="false">
      <a id="squeeze:Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">squeeze</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Drop all columns from the Frame which have nothing but NA values.</p>
    </li><li visbl="pub" name="org.saddle.Frame#stack" data-isabs="false">
      <a id="stack[O1, O2, V](Splitter[CX, O1, O2],Stacker[RX, O2, V],ORD[O1],ORD[O2],ST[O1],ST[O2]):Frame[V, O1, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stack</span><span class="tparams">[<span name="O1">O1</span>, <span name="O2">O2</span>, <span name="V">V</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="splt">splt: <a name="org.saddle.index.Splitter" class="extype" href="index/Splitter.html">Splitter</a>[CX, O1, O2]</span>, <span name="stkr">stkr: <a name="org.saddle.index.Stacker" class="extype" href="index/Stacker.html">Stacker</a>[RX, O2, V]</span>, <span name="ord1">ord1: ORD[O1]</span>, <span name="ord2">ord2: ORD[O2]</span>, <span name="m1">m1: ST[O1]</span>, <span name="m2">m2: ST[O2]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[V, O1, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stack pivots the innermost column labels to the innermost row labels.</p><div class="fullcomment"><div class="comment cmt"><p>Stack pivots the innermost column labels to the innermost row labels. That is, it splits
a col index of tuple keys of arity N into a new col index having arity N-1 and a remaining
index C, and forms a new row index by stacking the existing row index with C. The
resulting Frame has values as in the original Frame indexed by the corresponding keys. It
does the reverse of unstack.
</p></div><dl class="paramcmts block"><dt class="tparam">O1</dt><dd class="cmt"><p>The N-1 arity column index type</p></dd><dt class="tparam">O2</dt><dd class="cmt"><p>The 1-arity type of split-out index C</p></dd><dt class="tparam">V</dt><dd class="cmt"><p>The type of the stacked row index
</p></dd><dt class="param">splt</dt><dd class="cmt"><p>An implicit instance of Splitter to do the splitting</p></dd><dt class="param">stkr</dt><dd class="cmt"><p>An implicit instance of Stacker to do the stacking</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#stringify" data-isabs="false">
      <a id="stringify(Int,Int):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stringify</span><span class="params">(<span name="nrows">nrows: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">10</span></span>, <span name="ncols">ncols: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">10</span></span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a string representation of Frame</p><div class="fullcomment"><div class="comment cmt"><p>Creates a string representation of Frame</p></div><dl class="paramcmts block"><dt class="param">nrows</dt><dd class="cmt"><p>Max number of rows to include</p></dd><dt class="param">ncols</dt><dd class="cmt"><p>Max number of rows to include
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#tail" data-isabs="false">
      <a id="tail(Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tail</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract last n rows
</p><div class="fullcomment"><div class="comment cmt"><p>Extract last n rows
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>number of rows to extract
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#tailCol" data-isabs="false">
      <a id="tailCol(Int):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tailCol</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract last n columns
</p><div class="fullcomment"><div class="comment cmt"><p>Extract last n columns
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>number of columns to extract
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#toColSeq" data-isabs="false">
      <a id="toColSeq:IndexedSeq[(CX, Series[RX, T])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toColSeq</span><span class="result">: IndexedSeq[(CX, <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Produce an indexed sequence of pairs of column index value and
column Series.</p>
    </li><li visbl="pub" name="org.saddle.Frame#toMat" data-isabs="false">
      <a id="toMat:Mat[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMat</span><span class="result">: <a name="org.saddle.Mat" class="extype" href="Mat.html">Mat</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extract the Mat embodied in the values of the Frame (dropping any indexing
information)
</p>
    </li><li visbl="pub" name="org.saddle.Frame#toRowSeq" data-isabs="false">
      <a id="toRowSeq:IndexedSeq[(RX, Series[CX, T])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toRowSeq</span><span class="result">: IndexedSeq[(RX, <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[CX, T])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Produce an indexed sequence of pairs of row index value and
row Series
</p>
    </li><li visbl="pub" name="org.saddle.Frame#toSeq" data-isabs="false">
      <a id="toSeq:IndexedSeq[(RX, CX, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSeq</span><span class="result">: IndexedSeq[(RX, CX, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Produce an indexed sequence of triples of values in the Frame
in row-major order.</p>
    </li><li visbl="pub" name="org.saddle.Frame#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.Frame" class="extype" href="">Frame</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#transform" data-isabs="false">
      <a id="transform[U, SX]((Series[RX, T]) ⇒ Series[SX, U])(ST[U],ST[SX],ORD[SX]):Frame[SX, CX, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transform</span><span class="tparams">[<span name="U">U</span>, <span name="SX">SX</span>]</span><span class="params">(<span name="f">f: (<a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[RX, T]) ⇒ <a name="org.saddle.Series" class="extype" href="Series.html">Series</a>[SX, U]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ST[U]</span>, <span name="arg1">arg1: ST[SX]</span>, <span name="arg2">arg2: ORD[SX]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[SX, CX, U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Apply a function to each column series which results in another series (having possibly
a different index); return new frame whose row index is the the full outer join of all
the intermediately produced series (fast when all series have the same index), and having
the original column index.</p><div class="fullcomment"><div class="comment cmt"><p>Apply a function to each column series which results in another series (having possibly
a different index); return new frame whose row index is the the full outer join of all
the intermediately produced series (fast when all series have the same index), and having
the original column index.</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>Type of values of result series of function</p></dd><dt class="tparam">SX</dt><dd class="cmt"><p>Type of index of result series of function
</p></dd><dt class="param">f</dt><dd class="cmt"><p>Function to operate on each column as a series</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#unstack" data-isabs="false">
      <a id="unstack[O1, O2, V](Splitter[RX, O1, O2],Stacker[CX, O2, V],ORD[O1],ORD[O2],ST[O1],ST[O2]):Frame[O1, V, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unstack</span><span class="tparams">[<span name="O1">O1</span>, <span name="O2">O2</span>, <span name="V">V</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="splt">splt: <a name="org.saddle.index.Splitter" class="extype" href="index/Splitter.html">Splitter</a>[RX, O1, O2]</span>, <span name="stkr">stkr: <a name="org.saddle.index.Stacker" class="extype" href="index/Stacker.html">Stacker</a>[CX, O2, V]</span>, <span name="ord1">ord1: ORD[O1]</span>, <span name="ord2">ord2: ORD[O2]</span>, <span name="m1">m1: ST[O1]</span>, <span name="m2">m2: ST[O2]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[O1, V, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Unstack pivots the innermost row labels to the innermost col labels.</p><div class="fullcomment"><div class="comment cmt"><p>Unstack pivots the innermost row labels to the innermost col labels. That is, it splits
a row index of tuple keys of arity N into a new row index having arity N-1 and a remaining
index R, and forms a new col index by stacking the existing col index with R. The
resulting Frame has values as in the original Frame indexed by the corresponding keys.</p><p>For example:</p><pre>
scala&gt; Frame(Series(Vec(<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>,<span class="num">4</span>), Index((<span class="lit">'a'</span>,<span class="num">1</span>),(<span class="lit">'a'</span>,<span class="num">2</span>),(<span class="lit">'b'</span>,<span class="num">1</span>),(<span class="lit">'b'</span>,<span class="num">2</span>))), Series(Vec(<span class="num">5</span>,<span class="num">6</span>,<span class="num">7</span>,<span class="num">8</span>), Index((<span class="lit">'a'</span>,<span class="num">1</span>),(<span class="lit">'a'</span>,<span class="num">2</span>),(<span class="lit">'b'</span>,<span class="num">1</span>),(<span class="lit">'b'</span>,<span class="num">2</span>))))
res1: org.saddle.Frame[(<span class="std">Char</span>, <span class="std">Int</span>),<span class="std">Int</span>,<span class="std">Int</span>] =
[<span class="num">4</span> x <span class="num">2</span>]
        <span class="num">0</span>  <span class="num">1</span>
       -- --
a <span class="num">1</span> -&gt;  <span class="num">1</span>  <span class="num">5</span>
  <span class="num">2</span> -&gt;  <span class="num">2</span>  <span class="num">6</span>
b <span class="num">1</span> -&gt;  <span class="num">3</span>  <span class="num">7</span>
  <span class="num">2</span> -&gt;  <span class="num">4</span>  <span class="num">8</span>

scala&gt; res1.unstack
res2: org.saddle.Frame[<span class="std">Char</span>,(<span class="std">Int</span>, <span class="std">Int</span>),<span class="std">Int</span>] =
[<span class="num">2</span> x <span class="num">4</span>]
      <span class="num">0</span>     <span class="num">1</span>
      <span class="num">1</span>  <span class="num">2</span>  <span class="num">1</span>  <span class="num">2</span>
     -- -- -- --
a -&gt;  <span class="num">1</span>  <span class="num">2</span>  <span class="num">5</span>  <span class="num">6</span>
b -&gt;  <span class="num">3</span>  <span class="num">4</span>  <span class="num">7</span>  <span class="num">8</span>
</pre></div><dl class="paramcmts block"><dt class="tparam">O1</dt><dd class="cmt"><p>The N-1 arity row index type</p></dd><dt class="tparam">O2</dt><dd class="cmt"><p>The 1-arity type of split-out index R</p></dd><dt class="tparam">V</dt><dd class="cmt"><p>The type of the stacked col index
</p></dd><dt class="param">splt</dt><dd class="cmt"><p>An implicit instance of Splitter to do the splitting</p></dd><dt class="param">stkr</dt><dd class="cmt"><p>An implicit instance of Stacker to do the stacking</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="org.saddle.Frame#where" data-isabs="false">
      <a id="where(org.saddle.Series[_, Boolean]):Frame[RX, CX, T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">where</span><span class="params">(<span name="pred">pred: org.saddle.Series[_, Boolean]</span>)</span><span class="result">: <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create Frame whose rows satisfy the rule that their keys and values are chosen
via a Vec[Boolean] or a Series[_, Boolean] predicate when the latter contains a
true value.</p><div class="fullcomment"><div class="comment cmt"><p>Create Frame whose rows satisfy the rule that their keys and values are chosen
via a Vec[Boolean] or a Series[_, Boolean] predicate when the latter contains a
true value.</p></div><dl class="paramcmts block"><dt class="param">pred</dt><dd class="cmt"><p>Series[_, Boolean] (or Vec[Boolean] which will implicitly convert)
</p></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#xor" data-isabs="false">
      <a id="xor[B, That](B)(BinOp[XorOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">xor</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.XorOp" class="extype" href="ops/XorOp.html">XorOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Logical EXCLUSIVE OR</p><div class="fullcomment"><div class="comment cmt"><p>Logical EXCLUSIVE OR</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#|" data-isabs="false">
      <a id="|[B, That](B)(BinOp[BitOr, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bar">|</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.BitOr" class="extype" href="ops/BitOr.html">BitOr</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Bit-wise OR</p><div class="fullcomment"><div class="comment cmt"><p>Bit-wise OR</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li><li visbl="pub" name="org.saddle.ops.NumericOps#||" data-isabs="false">
      <a id="||[B, That](B)(BinOp[OrOp, Frame[RX, CX, T], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bar$bar">||</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="other">other: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="op">op: <a name="org.saddle.ops.BinOp" class="extype" href="ops/BinOp.html">BinOp</a>[<a name="org.saddle.ops.OrOp" class="extype" href="ops/OrOp.html">OrOp</a>, <a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Logical OR</p><div class="fullcomment"><div class="comment cmt"><p>Logical OR</p></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>type of the other operand</p></dd><dt class="tparam">That</dt><dd class="cmt"><p>result type of operation
</p></dd><dt class="param">other</dt><dd class="cmt"><p>other operand instance</p></dd><dt class="param">op</dt><dd class="cmt"><p>implicit evidence for operation between this and other</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a></dd></dl></div>
    </li></ol>
            </div>

        
        </div>

        <div id="inheritedMembers">
        <div name="org.saddle.ops.NumericOps" class="parent">
              <h3>Inherited from <a name="org.saddle.ops.NumericOps" class="extype" href="ops/NumericOps.html">NumericOps</a>[<a name="org.saddle.Frame" class="extype" href="">Frame</a>[RX, CX, T]]</h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>